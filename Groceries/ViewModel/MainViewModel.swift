import SwiftUI
import JWTDecode

class MainViewModel: ObservableObject {
    static var shared: MainViewModel = MainViewModel()
    
    // @Published: Khi d·ªØ li·ªáu thay ƒë·ªïi, giao di·ªán s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t.
    @Published var txtFullName: String = ""
    @Published var txtEmail: String = ""
    @Published var txtPassword: String = ""
    @Published var txtPhone: String = ""
    @Published var txtAddress: String = ""
    @Published var isShowPassword: Bool = false
    
    @Published var showError = false
    @Published var errorMessage = ""
    @Published var isUserLogin: Bool = false
    
    @Published var userObj: UserModel = UserModel(dict: [:])
    @Published var token: String = "" // D√πng ƒë·ªÉ l∆∞u tempToken ho·∫∑c accessToken
    @Published var refreshToken: String = ""
    
    @Published var showSuccess = false
    @Published var successMessage = ""
    @Published var navigateTo = false
    @Published var navigateToOTP = false
    @Published var navigationResettoLog = false
    
    // Reset password
    @Published var otpCode: String = ""
    @Published var navigateToLogin = false
    
    // Change password
    @Published var txtOldPassword: String = ""
    
    // Address ViewModel
    @Published var userRole: String = ""
    
    // Th·ªùi gian h·∫øt h·∫°n c·ªßa accessToken
    private var tokenExpirationDate: Date? {
        get { Utils.UDValue(key: "tokenExpirationDate") as? Date }
        // V√≠ d·ª•: N·∫øu UserDefaults c√≥ key "tokenExpirationDate" v·ªõi gi√° tr·ªã 2025-06-26 17:00:00, get tr·∫£ v·ªÅ Date t∆∞∆°ng ·ª©ng. N·∫øu kh√¥ng c√≥ key, tr·∫£ v·ªÅ nil.
        set { Utils.UDSET(data: newValue, key: "tokenExpirationDate") }
        // V√≠ d·ª•: Khi ƒëƒÉng nh·∫≠p th√†nh c√¥ng, serviceCallLogin gi·∫£i m√£ token v√† g√°n tokenExpirationDate = Date(timeIntervalSince1970: 1719483600) (t∆∞∆°ng ·ª©ng 2025-06-27 12:00:00). Gi√° tr·ªã n√†y ƒë∆∞·ª£c l∆∞u v√†o UserDefaults.
    }
    
    init() {
        if Utils.UDValueBool(key: Globs.userLogin) {
            let userDict = Utils.UDValue(key: Globs.userPayload) as? NSDictionary ?? [:]
            // UserDefaults : "userPayload": {id: 1, email: "user@example.com"}, userDict ch·ª©a dictionary n√†y. N·∫øu kh√¥ng c√≥, userDict = [:].
            self.setUserData(uDict: userDict)
        }
    }
    
    // MARK: - Log In
    func serviceCallLogin() {
        if txtEmail.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter a valid email address"
                self.showError = true
            }
            return
        }
        
        if txtPassword.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter a valid password"
                self.showError = true
            }
            return
        }
        /*
         {
           "message": "Login successful",
           "token": "abc123",
           "refreshToken": "xyz789",
           "user": { "id": 1, "email": "user@example.com" }
         }
         */
        let parameters = ["email": txtEmail, "password": txtPassword]
        ServiceCall.post(parameter: parameters as NSDictionary, path: Globs.SV_LOGIN) { responseObj in
            if let response = responseObj as? NSDictionary {
                if response["message"] as? String == "Login successful" {
                    self.token = response["token"] as? String ?? "" // response["token"] = "abc123" ‚Üí self.token = "abc123"
                    self.refreshToken = response["refreshToken"] as? String ?? ""
                    
                    let userDict = response["user"] as? NSDictionary ?? [:] // userDict = {id: 1, email: "user@example.com"}
                    
                    var payloadDict = userDict.mutableCopy() as! NSMutableDictionary // T·∫°o b·∫£n sao c√≥ th·ªÉ ch·ªânh s·ª≠a (NSMutableDictionary) c·ªßa userDict .mutableCopy(): T·∫°o b·∫£n sao ƒë·ªÉ c√≥ th·ªÉ th√™m/s·ª≠a key-value.
                    payloadDict["token"] = self.token
                    payloadDict["refreshToken"] = self.refreshToken
                    // {id: 1, email: "user@example.com", token: "abc123", refreshToken: "xyz789"}.
                    
                    // L∆∞u th·ªùi gian h·∫øt h·∫°n c·ªßa access token
                    // self.token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjMiLCJleHAiOjE3MTk0ODM2MDB9..."
                    do {
                        let jwt = try decode(jwt: self.token) // jwt {sub: "123", exp: 1719483600} (2025-06-27 12:00:00).
                        let expClaim = jwt.claim(name: "exp") // expClaim = 1719483600
                        if let exp = expClaim.double { // exp = 1719483600.0 (2025-06-27 12:00:00)
                            self.tokenExpirationDate = Date(timeIntervalSince1970: exp) // convert Date
                            /* exp = 1719483600 ‚Üí self.tokenExpirationDate = 2025-06-27 12:00:00.
                             Gi√° tr·ªã n√†y ƒë∆∞·ª£c l∆∞u v√†o UserDefaults v·ªõi key "tokenExpirationDate". */
                            print("Access token expiration date: \(String(describing: self.tokenExpirationDate))")
                        } else {
                            print("Failed to extract 'exp' claim from access token")
                        }
                    } catch {
                        print("Failed to decode access token: \(error)")
                    }

                    // Gi·∫£i m√£ refresh token ƒë·ªÉ l·∫•y th·ªùi gian h·∫øt h·∫°n
                    // self.token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjMiLCJleHAiOjE3MTk0ODM2MDB9..."
                    do {
                        let jwt = try decode(jwt: self.refreshToken) // jwt {sub: "123", exp: 1719483600} (2025-06-27 12:00:00).
                        let expClaim = jwt.claim(name: "exp") // expClaim = 1719483600
                        if let exp = expClaim.double { // exp = 1719483600.0 (2025-06-27 12:00:00)
                            payloadDict["refreshTokenExpiration"] = Int(exp) // convert Int
                            /* payloadDict["refreshTokenExpiration"] = 1719570000.
                             payloadDict = {id: 1, email: "user@example.com", token: "abc123", refreshToken: "xyz789", refreshTokenExpiration: 1719570000}.*/
                            print("Refresh token expiration date: \(Date(timeIntervalSince1970: exp))")
                        } else {
                            print("Failed to extract 'exp' claim from refresh token")
                        }
                    } catch {
                        print("Failed to decode refresh token: \(error)")
                    }
                    //üìç tokenExpirationDate = 2025-06-27 12:00:00, refreshTokenExpiration = 1719570000
                    self.setUserData(uDict: payloadDict)
                    
                    DispatchQueue.main.async {
                        self.navigateToLogin = false
                        self.navigateTo = true
                    }
                } // if 2
                else {
                    DispatchQueue.main.async {
                        self.errorMessage = response["error"] as? String ?? "Login failed"
                        self.showError = true
                    }
                }
            } // if 1
        } failure: { error in
            DispatchQueue.main.async {
                self.errorMessage = error?.localizedDescription ?? "Network error"
                self.showError = true
            }
        }
    }
    
    // MARK: - Sign Up
    func serviceCallSignUp() {
        if txtFullName.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter your full name"
                self.showError = true
            }
            return
        }

        if !txtEmail.isValidEmail {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter a valid email address"
                self.showError = true
            }
            return
        }

        if txtPassword.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter a valid password"
                self.showError = true
            }
            return
        }

        if txtPhone.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter your phone number"
                self.showError = true
            }
            return
        }

        if txtAddress.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter your address"
                self.showError = true
            }
            return
        }

        let parameters = [
            "fullName": txtFullName,
            "email": txtEmail,
            "password": txtPassword,
            "phone": txtPhone,
            "address": txtAddress
        ]
        // ["fullName": "Nguy·ªÖn VƒÉn A", "email": "user@example.com", "password": "pass123", "phone": "0123456789", "address": "H√† N·ªôi"].

        ServiceCall.post(parameter: parameters as NSDictionary, path: Globs.SV_SIGN_UP) { responseObj in
            if let response = responseObj as? NSDictionary {
                /*{
                 "message": "User registered successfully. Please verify your email with OTP",
                 "user": { "id": 1, "email": "user@example.com" } } */
                if response["message"] as? String == "User registered successfully. Please verify your email with OTP" {
                    // G·ªçi serviceCallSendOTP v√† ch·ªù n√≥ ho√†n t·∫•t
                    self.serviceCallSendOTP { success in
                        if success {
                            // {"message": "OTP has been sent", "tempToken": "otp123"}.
                            var userDict = response["user"] as? NSMutableDictionary ?? NSMutableDictionary()
                            userDict.removeObject(forKey: "refreshToken")
                            userDict["token"] = self.token
                            // self.token: ƒê∆∞·ª£c g√°n trong serviceCallSendOTP

                            Utils.UDSET(data: userDict, key: Globs.userPayload) // token ƒë∆∞·ª£c l∆∞u v√†o UserDefaults
                            // L∆∞u {id: 1, email: "user@example.com", token: "otp123"} v√†o UserDefaults v·ªõi key "userPayload".
                            DispatchQueue.main.async {
                                self.userObj = UserModel(dict: userDict) //UserModel(dict:) (gi·∫£ ƒë·ªãnh) ch·ªâ l·∫•y c√°c tr∆∞·ªùng c·∫ßn thi·∫øt (nh∆∞ id, email), c√≥ th·ªÉ b·ªè qua token khi t·∫°o userObj.
                                self.successMessage = "Registration successful! Please verify your email"
                                self.showSuccess = true
                                self.navigateToOTP = true
                            }
                        } else {
                            DispatchQueue.main.async {
                                self.errorMessage = "Failed to send OTP after registration"
                                self.showError = true
                            }
                        }
                    }
                } else {
                    DispatchQueue.main.async {
                        self.errorMessage = response["error"] as? String ?? "Registration failed"
                        self.showError = true
                    }
                }
            }
        } failure: { error in
            DispatchQueue.main.async {
                self.errorMessage = error?.localizedDescription ?? "Network error"
                self.showError = true
            }
        }
    }
    
    /*
     {
         "message": "OTP has been sent",
         "tempToken": "otp123"
     }
     */
    // S·ª≠a ƒë·ªïi serviceCallSendOTP ƒë·ªÉ h·ªó tr·ª£ callback
        func serviceCallSendOTP(completion: @escaping (Bool) -> Void) {
            let parameters = ["email": txtEmail]

            ServiceCall.post(parameter: parameters as NSDictionary, path: Globs.SV_SEND_OTP) { responseObj in
                if let response = responseObj as? NSDictionary {
                    if response["message"] as? String == "OTP has been sent" {
                        DispatchQueue.main.async {
                            self.token = response["tempToken"] as? String ?? ""
                            self.successMessage = "OTP sent successfully"
                            self.showSuccess = true
                            completion(true)
                        }
                    } else {
                        DispatchQueue.main.async {
                            self.errorMessage = response["error"] as? String ?? "Failed to send OTP"
                            self.showError = true
                            completion(false)
                        }
                    }
                }
            } failure: { error in
                DispatchQueue.main.async {
                    self.errorMessage = error?.localizedDescription ?? "Network error"
                    self.showError = true
                    completion(false)
                }
            }
        }
        
        // MARK: - Send OTP
        func serviceCallSendOTP() {
            let parameters = ["email": txtEmail]

            ServiceCall.post(parameter: parameters as NSDictionary, path: Globs.SV_SEND_OTP) { responseObj in
                if let response = responseObj as? NSDictionary {
                    if response["message"] as? String == "OTP has been sent" {
                        DispatchQueue.main.async {
                            self.token = response["tempToken"] as? String ?? ""
                            self.successMessage = "OTP sent successfully"
                            self.showSuccess = true
                        }
                    } else {
                        DispatchQueue.main.async {
                            self.errorMessage = response["error"] as? String ?? "Failed to send OTP"
                            self.showError = true
                        }
                    }
                }
            } failure: { error in
                DispatchQueue.main.async {
                    self.errorMessage = error?.localizedDescription ?? "Network error"
                    self.showError = true
                }
            }
        }
    
    // MARK: - Reset Password
    func serviceCallResetPassword() {
        if txtEmail.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter your email"
                self.showError = true
            }
            return
        }
        
        if otpCode.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter the OTP"
                self.showError = true
            }
            return
        }
        
        if txtPassword.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter a new password"
                self.showError = true
            }
            return
        }
        
        let parameters = [
            "tempToken": token,
            "otp": otpCode,
            "newPassword": txtPassword
        ]
        
        ServiceCall.post(parameter: parameters as NSDictionary, path: Globs.SV_RESET_PASSWORD) { responseObj in
            if let response = responseObj as? NSDictionary {
                if response["message"] as? String == "Your password has been reset successfully." {
                    DispatchQueue.main.async {
                        self.navigationResettoLog = true
                        self.clearSession() // login again
                        self.successMessage = "Your password has updated. Please log in again!"
                        self.showSuccess = true
                    }
                } else {
                    DispatchQueue.main.async {
                        self.errorMessage = response["error"] as? String ?? "Failed to reset password"
                        self.showError = true
                    }
                }
            }
        } failure: { error in
            DispatchQueue.main.async {
                self.errorMessage = error?.localizedDescription ?? "Network error"
                self.showError = true
            }
        }
    }
    // MARK: - Change Password
    func serviceCallChangePassword() {
        guard !userObj.email.isEmpty else {
            DispatchQueue.main.async {
                self.errorMessage = "User email not found. Please log in again."
                self.showError = true
                self.logout()
            }
            return
        }
        
        if txtOldPassword.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter your old password"
                self.showError = true
            }
            return
        }
        
        if txtPassword.isEmpty {
            DispatchQueue.main.async {
                self.errorMessage = "Please enter a new password"
                self.showError = true
            }
            return
        }
        
        let parameters = [
            "email": userObj.email,
            "oldPassword": txtOldPassword,
            "newPassword": txtPassword
        ]
        
        ServiceCall.post(parameter: parameters as NSDictionary, path: Globs.SV_CHANGE_PASSWORD) { responseObj in
            if let response = responseObj as? NSDictionary {
                if response["message"] as? String == "Password changed successfully" {
                    DispatchQueue.main.async {
                        self.successMessage = "Password changed successfully!"
                        self.showSuccess = true
                        self.logout() // G·ªçi logout() ƒë·ªÉ x√≥a phi√™n ƒëƒÉng nh·∫≠p (nh∆∞ token, refreshToken, userObj, userDict) v√† ƒëi·ªÅu h∆∞·ªõng v·ªÅ m√†n h√¨nh ƒëƒÉng nh·∫≠p.
                    }
                } else {
                    DispatchQueue.main.async {
                        self.errorMessage = response["error"] as? String ?? "Failed to change password"
                        self.showError = true
                    }
                }
            }
        } failure: { error in
            DispatchQueue.main.async {
                self.errorMessage = error?.localizedDescription ?? "Network error"
                self.showError = true
            }
        }
    }
    // MARK: - Token Management
    private var isRefreshingToken = false

    private func isTokenExpired() -> Bool {
        guard !token.isEmpty, let expirationDate = tokenExpirationDate else {
            print("Token is empty or expiration date is not set")
            return true
        }
        let isExpired = Date() >= expirationDate
        /* So s√°nh th·ªùi gian hi·ªán t·∫°i (Date()) v·ªõi tokenExpirationDate. N·∫øu hi·ªán t·∫°i l·ªõn h∆°n ho·∫∑c b·∫±ng, token ƒë√£ h·∫øt h·∫°n.
         N·∫øu tokenExpirationDate = 2025-06-27 17:00:00 v√† hi·ªán t·∫°i l√† 2025-06-27 17:48:00, isExpired = true */
        print("Token expiration check: \(isExpired ? "Expired" : "Valid") - Expiration Date: \(expirationDate)")
        return isExpired // Tr·∫£ v·ªÅ true ƒë·ªÉ k√≠ch ho·∫°t l√†m m·ªõi token || false n·∫øu c√≤n h·ª£p l·ªá
    }

    private func isRefreshTokenExpired() -> Bool {
        guard let userDict = Utils.UDValue(key: Globs.userPayload) as? NSDictionary,
              let exp = userDict["refreshTokenExpiration"] as? Int else {
            print("Refresh token expiration date not set")
            return true
        }
        let expirationDate = Date(timeIntervalSince1970: TimeInterval(exp)) // exp = 1719573600 ‚Üí expirationDate = 2025-06-28 17:00:00.
        let isExpired = Date() >= expirationDate // N·∫øu hi·ªán t·∫°i l·ªõn h∆°n ho·∫∑c b·∫±ng, refresh token ƒë√£ h·∫øt h·∫°n.
        print("Refresh token expiration check: \(isExpired ? "Expired" : "Valid") - Expiration Date: \(expirationDate)")
        return isExpired
    }

    func refreshAccessToken(completion: @escaping (Bool) -> Void) {
        guard !isRefreshingToken else { // N·∫øu kh√¥ng ƒëang l√†m m·ªõi (!isRefreshingToken = true), ti·∫øp t·ª•c th·ª±c thi h√†m. N·∫øu ƒëang l√†m m·ªõi (!isRefreshingToken = false), ch·∫°y block else
            print("Already refreshing token, skipping duplicate request")
            completion(false)
            return
        }

        guard !refreshToken.isEmpty else {
            // N·∫øu c√≥ gi√° tr·ªã (!refreshToken.isEmpty = true), ti·∫øp t·ª•c h√†m. N·∫øu r·ªóng (!refreshToken.isEmpty = false), ch·∫°y block else.
            // N·∫øu refreshToken r·ªóng (do ch∆∞a ƒëƒÉng nh·∫≠p, clearSession(), ho·∫∑c l·ªói), kh√¥ng th·ªÉ l√†m m·ªõi token, n√™n ph·∫£i ƒëƒÉng xu·∫•t ƒë·ªÉ y√™u c·∫ßu ƒëƒÉng nh·∫≠p l·∫°i.
            print("Refresh token is empty, cannot refresh access token")
            DispatchQueue.main.async {
                self.errorMessage = "Session expired. Please log in again."
                self.showError = true
                self.logout()
            }
            completion(false)
            return
        }

        if isRefreshTokenExpired() { // true n·∫øu refresh token h·∫øt h·∫°n, false n·∫øu c√≤n h·ª£p l·ªá
            print("Refresh token has expired, logging out user")
            DispatchQueue.main.async {
                self.errorMessage = "Session expired. Please log in again."
                self.showError = true
                self.logout()
            }
            completion(false)
            return
        }

        isRefreshingToken = true
        let parameters = ["refreshToken": refreshToken]
        print("Refreshing access token with refreshToken: \(refreshToken)")

        ServiceCall.post(parameter: parameters as NSDictionary, path: Globs.SV_REFRESH) { responseObj in // G·ª≠i refreshToken ƒë·ªÉ nh·∫≠n access token m·ªõi.
            self.isRefreshingToken = false
            if let response = responseObj as? NSDictionary { // responseObj = {"accessToken": "new123", "expiresIn": 3600}
                if let newAccessToken = response["accessToken"] as? String {
                    print("New access token received: \(newAccessToken)")
                    DispatchQueue.main.async {
                        self.token = newAccessToken
                        do {
                            let jwt = try decode(jwt: newAccessToken) // {exp: 1719667500} (3:00 PM ng√†y 28/6/2025)
                            let expClaim = jwt.claim(name: "exp") // expClaim = 1719667500
                            if let exp = expClaim.double {
                                self.tokenExpirationDate = Date(timeIntervalSince1970: exp)
                                // exp = 1719667500 (3:00 PM ng√†y 28/6/2025). D√≤ng n√†y ƒë·∫∑t tokenExpirationDate = 2025-06-28 15:00:00. Minh d√πng token ƒë·∫øn 3:00 PM
                                print("New token expiration date: \(String(describing: self.tokenExpirationDate))")
                            } else {
                                let expiresIn = response["expiresIn"] as? Int ?? 3600
                                self.tokenExpirationDate = Date().addingTimeInterval(TimeInterval(expiresIn))
                                print("New token expiration date (default): \(String(describing: self.tokenExpirationDate))")
                            }
                        } catch {
                            print("Failed to decode new access token: \(error)")
                            let expiresIn = response["expiresIn"] as? Int ?? 3600 // expiresIn = 7200. N·∫øu kh√¥ng c√≥ expiresIn, d√πng 3600
                            self.tokenExpirationDate = Date().addingTimeInterval(TimeInterval(expiresIn)) // expiresIn = 7200, hi·ªán t·∫°i l√† 02:15 PM. tokenExpirationDate = 2025-06-28 16:15:00.
                            print("New token expiration date (default): \(String(describing: self.tokenExpirationDate))")
                        }
                        if let userDict = Utils.UDValue(key: Globs.userPayload) as? NSMutableDictionary {
                            userDict["token"] = self.token
                            Utils.UDSET(data: userDict, key: Globs.userPayload) // C·∫≠p nh·∫≠t token trong userDict, l∆∞u v√†o UserDefaults
                            print("Updated token in UserDefaults")
                        }
                    }
                    completion(true)
                } else {
                    print("Failed to refresh token: No access token in response")
                    DispatchQueue.main.async {
                        self.errorMessage = "Failed to refresh token"
                        self.showError = true
                        self.logout()
                    }
                    completion(false)
                }
            } else {
                print("Failed to refresh token: Invalid response format")
                DispatchQueue.main.async {
                    self.errorMessage = "Failed to refresh token"
                    self.showError = true
                    self.logout()
                }
                completion(false)
            }
        } failure: { error in
            self.isRefreshingToken = false
            print("Failed to refresh token: Network error - \(error?.localizedDescription ?? "Unknown error")")
            DispatchQueue.main.async {
                self.errorMessage = error?.localizedDescription ?? "Network error"
                self.showError = true
                self.logout()
            }
            completion(false)
        }
    }

    public enum HTTPMethod: String {
        case get = "GET"
        case post = "POST"
        case delete = "DELETE"
    }

    public func callApiWithTokenCheck(method: HTTPMethod, path: String, parameters: NSDictionary, withSuccess: @escaping (Any?) -> Void, failure: @escaping (Error?) -> Void) {
        // Minh ƒëƒÉng nh·∫≠p l√∫c 01:00 PM, nh·∫≠n token = "abc123" (h·∫øt h·∫°n 02:00 PM) v√† refreshToken = "xyz789".
        // T·∫°i 02:53 PM, isTokenExpired() = true (token h·∫øt h·∫°n), !refreshToken.isEmpty = true (c√≥ refresh token). Block if ch·∫°y.
        if isTokenExpired() && !refreshToken.isEmpty {
            print("Token expired, attempting to refresh token before calling API: \(path)")
            refreshAccessToken { success in
                if success {
                    print("Token refreshed successfully, proceeding with API call: \(path)")
                    self.performApiCall(method: method, path: path, parameters: parameters, withSuccess: withSuccess, failure: failure)
                } else {
                    print("Failed to refresh token, API call aborted: \(path)")
                    failure(nil)
                }
            }
        } else if token.isEmpty {
            print("No token available, user must log in again")
            DispatchQueue.main.async {
                self.errorMessage = "Session expired. Please log in again."
                self.showError = true
                self.logout()
            }
            failure(nil)
        } else {
            print("Token is valid, proceeding with API call: \(path)")
            self.performApiCall(method: method, path: path, parameters: parameters, withSuccess: withSuccess, failure: failure)
        }
    }

    private func performApiCall(method: HTTPMethod, path: String, parameters: NSDictionary, withSuccess: @escaping (Any?) -> Void, failure: @escaping (Error?) -> Void) {
        switch method {
        case .get:
            ServiceCall.get(path: path, withSuccess: { responseObj in
                print("GET API call successful: \(path) - Response: \(String(describing: responseObj))")
                withSuccess(responseObj)
            }, failure: { error in
                print("GET API call failed: \(path) - Error: \(error?.localizedDescription ?? "Unknown error")")
                failure(error)
            })
        case .post:
            ServiceCall.post(parameter: parameters, path: path) { responseObj in
                print("POST API call successful: \(path) - Response: \(String(describing: responseObj))")
                withSuccess(responseObj)
            } failure: { error in
                print("POST API call failed: \(path) - Error: \(error?.localizedDescription ?? "Unknown error")")
                failure(error)
            }
        case .delete:
            ServiceCall.delete(path: path, withSuccess: { responseObj in
                print("DELETE API call successful: \(path) - Response: \(String(describing: responseObj))")
                withSuccess(responseObj)
            }, failure: { error in
                print("DELETE API call failed: \(path) - Error: \(error?.localizedDescription ?? "Unknown error")")
                failure(error)
            })
        }
    }
    
    // Logout
    func logout() {
        DispatchQueue.main.async {
            self.clearSession()
            self.isUserLogin = false // make sure User Login
            self.navigateToLogin = true
            self.navigateTo = false
            self.navigateToOTP = false
        }
    }
        
    // Delete session/tempToken
    func clearSession() {
        self.token = ""
        self.refreshToken = ""
        self.isUserLogin = false
        
        self.userObj = UserModel(dict: [:]) // X√≥a th√¥ng tin ng∆∞·ªùi d√πng (nh∆∞ id, email).
        self.navigateTo = false
        
        self.txtEmail = ""
        self.txtPassword = ""
        self.txtOldPassword = ""
        self.txtFullName = ""
        self.txtPhone = ""
        self.txtAddress = ""
        self.isShowPassword = false
        self.otpCode = ""
        
        self.showError = false
        self.errorMessage = ""
        self.showSuccess = false
        self.successMessage = ""
        
        // L∆∞u v√†o UserDefaults
        Utils.UDSET(data: false, key: Globs.userLogin) // ƒë·ªÉ ƒë√°nh d·∫•u ch∆∞a ƒëƒÉng nh·∫≠p.
        Utils.UDSET(data: [:], key: Globs.userPayload) // ƒë·ªÉ x√≥a th√¥ng tin ng∆∞·ªùi d√πng.
        Utils.UDSET(data: 0, key: "userId") // ƒë·ªÉ x√≥a ID ng∆∞·ªùi d√πng.
    }

    // MARK: - Set User Data
    func setUserData(uDict: NSDictionary) {
        if let userId = uDict["id"] as? Int {
            Utils.UDSET(data: userId, key: "userId") // uDict["id"] = 1 ‚Üí UserDefaults.standard.set(1, forKey: "userId").
            print("Stored userId in UserDefaults: \(userId)")
        } else {
            print("Failed to store userId: 'id' not found in user dictionary")
        }
        
        Utils.UDSET(data: uDict, key: Globs.userPayload)
        // L∆∞u to√†n b·ªô uDict v√†o UserDefaults : uDict["id"] = 1 ‚Üí UserDefaults.standard.set(1, forKey: "userId").
        Utils.UDSET(data: true, key: Globs.userLogin)
        // ƒê·∫∑t true v√†o UserDefaults v·ªõi key Globs.userLogin ƒë·ªÉ ƒë√°nh d·∫•u ƒë√£ ƒëƒÉng nh·∫≠p.
        
        DispatchQueue.main.async {
            self.userObj = UserModel(dict: uDict) // T·∫°o UserModel t·ª´ uDict : userObj ch·ª©a id: 1, email: "user@example.com"
            self.isUserLogin = true
            self.token = uDict["token"] as? String ?? ""
            self.refreshToken = uDict["refreshToken"] as? String ?? ""
            
            self.userRole = uDict["role"] as? String ?? "" // uDict["role"] = "ADMIN" ‚Üí userRole = "ADMIN"
            
            self.txtFullName = ""
            self.txtEmail = ""
            self.txtPassword = ""
            self.txtPhone = ""
            self.txtAddress = ""
            self.isShowPassword = false
            // X√≥a c√°c @Published properties li√™n quan ƒë·∫øn UI nh·∫≠p li·ªáu ƒë·ªÉ l√†m s·∫°ch sau ƒëƒÉng nh·∫≠p.
        }
    }
    
    func setUser(uDict: NSDictionary) { // gi·ªëng setUserData nh∆∞ng kh√¥ng l∆∞u token, refreshToken, userRole.
        if let userId = uDict["id"] as? Int {
            Utils.UDSET(data: userId, key: "userId")
            print("Stored userId in UserDefaults: \(userId)")
        } else {
            print("Failed to store userId: 'id' not found in user dictionary")
        }
        
        Utils.UDSET(data: uDict, key: Globs.userPayload)
        Utils.UDSET(data: true, key: Globs.userLogin)

        DispatchQueue.main.async {
            self.userObj = UserModel(dict: uDict)
            self.isUserLogin = true
            
            self.txtFullName = ""
            self.txtEmail = ""
            self.txtPassword = ""
            self.isShowPassword = false
        }
    }
    
    func isAdmin() -> Bool {
        return userRole == "ADMIN"
    }
}
